---
title: "VarComp"
output:
  html_document: default
  pdf_document: default
date: "2025-04-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(matlib)
library(cubature)
library(latex2exp)
library(ggplot2)
library(MCMCpack)
library(coda)
```

#Variance Component Model Gibbs Sampler

The following is the data of interest. The rows represent the batches of which there are 6 in total. Each batch contains 5 elements.
```{r}
# Matrix giving the famous "dyestuff" batch data from Davies (1967).
# Defined so Ydye[i,j] equals yield (in grams) from j'th sample of i'th batch.
# Valid for i=1,2,3,4,5,6, and j=1,2,3,4,5, i.e. I=6 and J=5.

Ydye = t( matrix(
	c(1545, 1440, 1440, 1520, 1580,
         1540, 1555, 1490, 1560, 1495,
         1595, 1550, 1605, 1510, 1560,
         1445, 1440, 1595, 1465, 1545,
         1595, 1630, 1515, 1635, 1625,
         1520, 1455, 1450, 1480, 1445), nrow=5) )

J <- dim(Ydye)[2] # number of samples in each batch
I <- dim(Ydye)[1] # number of batches
```

The following code runs a Gibbs sampler for the model.

```{r}
gibbs_update_u <- function(x, z = rnorm(1,0,1)){
  a <- (a3*x[1]+b3*sum(x[4:(3+I)]))/(x[1]+I*b3)
  b <- sqrt(b3*x[1]/(x[1] + I*b3))
  x[3] <- a + b*z
  return(x)
}

gibbs_update_theta <- function(x, z = rnorm(I,0,1)){
  a <- (x[3]/x[1]+apply(Ydye, MARGIN = 1, FUN = sum)/x[2])/(1/x[1]+J/x[2])
  b <- sqrt(1/(1/x[1] + J/x[2]))
  b <- sqrt(x[1]*x[2]/(x[2] + J*x[1]))
  x[4:(3+I)]  <- a + b * z
  return(x)
}

gibbs_update_V <- function(x, g = rgamma(1, shape = a1+I/2, rate = 1)){
  b <- b1 +sum((x[4:(3+I)]-x[3])^2)/2
  x[1]  <- b/g
  return(x)
}

gibbs_update_W <- function(x, g = rgamma(1, shape = a2+I*J/2, rate = 1)){
  b <- b2 +sum((Ydye-x[4:(3+I)])^2)/2
  x[2]  <- b/g
  return(x)
}
```

Generate the initial value of $Y_0\sim \nu$
```{r}
par <- c(6, 6, 6, 6, 1600, 1600)

a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
```


```{r}
# M <- 10000 # number of iterations 
# 
# X <- c(100,200,900,rep(900,I))
# X_init <- X
# 
# V <- rinvgamma(1, a1, b1-1)
# W <- rinvgamma(1, a2, b2-1)
# u <- rnorm(1, a3, sqrt(b3))
# theta <- rnorm(I, apply(Ydye,2,mean), W/J)
# Y <- c(V[1], W[1], u[1], theta)
# Y_init <- Y
# 
# df_X <- data.frame(t(c(X,0,0)))
# df_Y <- data.frame(t(c(Y,0,0)))
# colnames(df_X) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")
# colnames(df_Y) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")
# 
# #a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
#   
# for (i in 1:M) {
#     for (coord in 1:4){
#       if (coord == 3) { # Modify coordinate u
#         z = rnorm(1,0,1)
#         X <- gibbs_update_u(X, z)
#         Y <- gibbs_update_u(Y, z)
#       }
#       else if (coord == 4) { # Modify all K thetas
#         z = rnorm(I,0,1)
#         X <- gibbs_update_theta(X, z)
#         Y <- gibbs_update_theta(Y, z)
#       }
#       else if (coord == 1) { # Modify coordinate V
#         g = rgamma(1, shape = a1+I/2, rate = 1)
#         X <- gibbs_update_V(X, g)
#         Y <- gibbs_update_V(Y, g)
#       }
#       else if (coord == 2) { # Modify coordinate W
#         g = rgamma(1, shape = a2+I*J/2, rate = 1)
#         X <- gibbs_update_W(X,g)
#         Y <- gibbs_update_W(Y,g)
#       }
#       df_X <- rbind(df_X,c(X, coord, i))
#       df_Y <- rbind(df_Y,c(Y, coord, i))
#     }
# }
```

```{r}
# save(df_X, file = "df_X_VarComp.RData")
# save(df_Y, file = "df_Y_VarComp.RData")
```

```{r}
load('df_X_VarComp.RData')
load('df_Y_VarComp.RData')
```

```{r}
df_X %>%
  filter(iter>9000, coord==1) %>% 
  ggplot(aes(x = iter, y = theta1)) +
  geom_line() + labs(title="theta1")

df_X %>%
  filter(iter>9000, coord==1) %>% 
  ggplot(aes(x = iter, y = mu)) +
  geom_line() + labs(title="mu")

df_X %>%
  filter(iter>9000, coord==1) %>% 
  ggplot(aes(x = iter, y = V)) +
  geom_line() + labs(title="V")

df_X %>%
  filter(iter>9000, coord==1) %>% 
  ggplot(aes(x = iter, y = W)) +
  geom_line() + labs(title="W")
```

```{r}
df_X %>%
  filter(iter>25, coord==1) %>% 
  ggplot(aes(x = iter, y = theta1)) +
  geom_line() + labs(title="theta1")

df_X %>%
  filter(iter>25, coord==1) %>% 
  ggplot(aes(x = iter, y = mu)) +
  geom_line() + labs(title="mu")

df_X %>%
  filter(iter>25, coord==1) %>% 
  ggplot(aes(x = iter, y = V)) +
  geom_line() + labs(title="V")

df_X %>%
  filter(iter>25, coord==1) %>% 
  ggplot(aes(x = iter, y = W)) +
  geom_line() + labs(title="W")
```

```{r}
df_X1 <- df_X %>% pivot_longer(cols = V:theta6, names_to = "names", values_to = "X")
df_Y1 <- df_Y %>% pivot_longer(cols = V:theta6, names_to = "names", values_to = "Y")

df <- left_join(df_X1, df_Y1, by=c('coord','iter','names'))
df <- df %>% mutate(diff = X-Y)

df_diff <- df %>%
  filter(coord ==1) %>%
  group_by(iter) %>%
  summarise(diff = sum(abs(diff)))
```


```{r}
df_diff %>%
  filter(iter>2) %>%
  ggplot(aes(x = iter, y = diff)) +
  geom_line() + labs(title = "Value of |X-Y|", subtitle = "Using common random number technique") +
  xlab("iteration") + ylab("value")
```

```{r}
#par <- c(6, 6, 6, 6, 1600, 1600)

simVCM <- function(){
  a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
  
  V <- rinvgamma(1, a1, b1-1)
  W <- rinvgamma(1, a2, b2-1)
  u <- rnorm(1, a3, sqrt(b3))
  theta <- rnorm(I, apply(Ydye,2,mean), W/J)
  Y <- c(V[1], W[1], u[1], theta)
  Y_init <- Y

  M <- 10000
  X <- c(100,200,900,rep(900,I))
  X_init <- X
  
  df_X <- data.frame(t(c(X,0,0)))
  df_Y <- data.frame(t(c(Y,0,0)))
  colnames(df_X) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")
  colnames(df_Y) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")
  
  a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
    
  for (i in 1:M) {
      for (coord in 1:4){
        if (coord == 3) { # Modify coordinate u
          z = rnorm(1,0,1)
          X <- gibbs_update_u(X, z)
          Y <- gibbs_update_u(Y, z)
        }
        else if (coord == 4) { # Modify all I thetas
          z = rnorm(I,0,1)
          X <- gibbs_update_theta(X, z)
          Y <- gibbs_update_theta(Y, z)
        }
        else if (coord == 1) { # Modify coordinate V
          g = rgamma(1, shape = a1+I/2, rate = 1)
          X <- gibbs_update_V(X, g)
          Y <- gibbs_update_V(Y, g)
        }
        else if (coord == 2) { # Modify coordinate W
          g = rgamma(1, shape = a2+I*J/2, rate = 1)
          X <- gibbs_update_W(X,g)
          Y <- gibbs_update_W(Y,g)
        }
        df_X <- rbind(df_X,c(X, coord, i))
        df_Y <- rbind(df_Y,c(Y, coord, i))
      }
  }

  df_X1 <- df_X %>% pivot_longer(cols = V:theta6, names_to = "names", values_to = "X")
  df_Y1 <- df_Y %>% pivot_longer(cols = V:theta6, names_to = "names", values_to = "Y")
  
  df <- left_join(df_X1, df_Y1, by=c('coord','iter','names'))
  df <- df %>% mutate(diff = X-Y)
  
  df_diff <- df %>%
    filter(coord ==1) %>%
    group_by(iter) %>%
    summarise(diff = sum(abs(diff)))
  return(df_diff)
}
```

```{r}
# df_diff1 <- simVCM()
# df_diff2 <- simVCM()
# df_diff3 <- simVCM()
# df_diff4 <- simVCM()
# df_diff5 <- simVCM()
# df_diff6 <- simVCM()
# df_diff7 <- simVCM()
# df_diff8 <- simVCM()
# df_diff9 <- simVCM()
# df_diff10 <- simVCM()
# 
# df_diff11 <- simVCM()
# df_diff12 <- simVCM()
# df_diff13 <- simVCM()
# df_diff14 <- simVCM()
# df_diff15 <- simVCM()
# df_diff16 <- simVCM()
# df_diff17 <- simVCM()
# df_diff18 <- simVCM()
# df_diff19 <- simVCM()
# df_diff20 <- simVCM()
# 
# df_diff1 <- df_diff1 %>% mutate(sim_no='1')
# df_diff2 <- df_diff2 %>% mutate(sim_no='2')
# df_diff3 <- df_diff3 %>% mutate(sim_no='3')
# df_diff4 <- df_diff4 %>% mutate(sim_no='4')
# df_diff5 <- df_diff5 %>% mutate(sim_no='5')
# df_diff6 <- df_diff6 %>% mutate(sim_no='6')
# df_diff7 <- df_diff7 %>% mutate(sim_no='7')
# df_diff8 <- df_diff8 %>% mutate(sim_no='8')
# df_diff9 <- df_diff9 %>% mutate(sim_no='9')
# df_diff10 <- df_diff10 %>% mutate(sim_no='10')
# 
# df_diff11 <- df_diff11 %>% mutate(sim_no='11')
# df_diff12 <- df_diff12 %>% mutate(sim_no='12')
# df_diff13 <- df_diff13 %>% mutate(sim_no='13')
# df_diff14 <- df_diff14 %>% mutate(sim_no='14')
# df_diff15 <- df_diff15 %>% mutate(sim_no='15')
# df_diff16 <- df_diff16 %>% mutate(sim_no='16')
# df_diff17 <- df_diff17 %>% mutate(sim_no='17')
# df_diff18 <- df_diff18 %>% mutate(sim_no='18')
# df_diff19 <- df_diff19 %>% mutate(sim_no='19')
# df_diff20 <- df_diff20 %>% mutate(sim_no='20')
```


```{r}
# df_diff_all <- rbind(df_diff1, df_diff2, df_diff3, df_diff4, df_diff5, df_diff6, df_diff7, df_diff8, df_diff9, df_diff10, df_diff11, df_diff12, df_diff13, df_diff14, df_diff15, df_diff16, df_diff17, df_diff1, df_diff19, df_diff20)
```

```{r}
# save(df_diff_all, file = "df_diff_all_VarComp.RData")
```

```{r}
load('df_diff_all_VarComp.RData')
```

```{r}
df_diff_all %>%
  group_by(iter) %>%
  summarise(mean_diff = mean(diff), min_diff =  min(diff), max_diff = max(diff)) %>% 
  filter(iter>2) %>%  
  ggplot(aes(x = iter)) +
  geom_ribbon(aes(ymin = min_diff, ymax = max_diff), fill = 'grey', alpha=0.5) +
  geom_line(aes(y = mean_diff)) +
  theme_bw() +
  #labs(title = TeX("Value of $||X_n-X'_n||_1$"), subtitle = "Using common random number technique") +
  xlab(TeX("n=iteration")) + ylab(TeX("$||X_n-X'_n||_1$"))
```



Calculate $K$ for the variance component model.

## Find the constant $K$ from theorem 4.4

We want to find the constant $K$ that will bound the distance between $X_n$ and the corresponding stationary distribution. We will do so, by making use of equation 15, which writes that for an $L\leq \int_{\mathcal{X}} f(\vec{\theta}, v, w, \mu) dx$,

$$K\leq \frac{1}{L}\sup_{(\vec{\theta}, v, w, \mu)}\frac{f(\vec{\theta}, v, w, \mu)}{\nu(\vec{\theta}, v, w, \mu)}$$

Step 1: Find an upper bound on $f/\nu$

Based on our calculations, the supremum of $\frac{f(\vec{\theta}, v, w, \mu)}{\nu(\vec{\theta}, v, w, \mu)}$ is bounded as follows for $$C=\frac{1}{(2\pi)^{\sum_{i=1}^K J_i/2}} \frac{1}{(\prod_{i=1}^{K} J_i)^{1/2}}$$,

\begin{align*}
	\sup_{(\vec{\theta}, v, w, \mu)}\frac{f(\vec{\theta}, v, w, \mu)}{\nu(\vec{\theta}, v, w, \mu)} &\leq C \left(\frac{1}{V^{K/2}}e^{-\frac{1}{2V}}\right)
	\left( \frac{1}{W^{(\sum_{i=1}^K J_i-K)/2}}e^{-\frac{\sum_{i=1}^K(\sum_{j=1}^{J_i} Y_{ij}^2 -J_i \bar{Y}_i^2)}{2W}} \right) \\
	&= C \frac{\Gamma(K/2-1)}{0.5^{K/2+1}}\left(\frac{0.5^{K/2+1}}{\Gamma(K/2-1)}\frac{1}{V^{K/2}}e^{-\frac{1}{2V}}\right)
	\frac{\Gamma(a_W)}{b_W^{a_w}}\left( \frac{b_W^{a_w}}{\Gamma(a_W)} \frac{1}{W^{a_w+1}}e^{-\frac{b_W}{W}} \right) \\
\end{align*}

Where $$a_W = (\sum_{i=1}^K J_i-K)/2 -1$$ and $$b_W=\frac{\sum_{i=1}^K(\sum_{j=1}^{J_i} Y_{ij}^2 -J_i \bar{Y}_i^2)}{2}$$

Since both of the functions for $V$ and $W$ are inverse gamma, the supremum occurs when $V^*=\frac{1}{2}\frac{1}{K/2-1}=\frac{1}{K-2}$ and $W^* = \frac{b_W}{a_W+1}=\frac{\sum_{i=1}^K(\sum_{j=1}^{J_i} Y_{ij}^2 -J_i \bar{Y}_i^2)}{\sum_{i=1}^K J_i-K}$. So that,

\begin{align*}
	\sup_{(\vec{\theta}, v, w, \mu)}\frac{f(\vec{\theta}, v, w, \mu)}{\nu(\vec{\theta}, v, w, \mu)} &\leq C \frac{\Gamma(K/2-1)}{0.5^{K/2+1}}\left(\frac{0.5^{K/2+1}}{\Gamma(K/2-1)}\frac{1}{(V^*)^{K/2}}e^{-\frac{1}{2V^*}}\right)
	\frac{\Gamma(a_W)}{b_W^{a_w}}\left( \frac{b_W^{a_w}}{\Gamma(a_W)} \frac{1}{(W^*)^{a_w+1}}e^{-\frac{b_W}{W^*}} \right) \\
\end{align*}

```{r}
a_w <- I*(J-1)/2-1
b_w <- 1
a_v <- I/2-1
b_v <- 1

V_star <- b_v/(a_v+1)
W_star <- b_w/(a_w+1)

C <- (b1/(b1-1))^a1*(b2/(b2-1))^a2*1/((2*pi)^(I*J/2)*J^(1/2))

sup_ratio <- C*gamma(a_v)/(b_v^a_v)*dinvgamma(V_star,a_v,b_v)*
  gamma(a_w)/(b_w^a_w)*dinvgamma(W_star,a_w,b_w)
sup_ratio <- C*(exp(-b_v/V_star)/(V_star)^(a_v+1))*(exp(-b_w/W_star)/(W_star)^(a_w+1))
```


Step 2: Find a lower bound on the unnormalized distribution function, $L$.


```{r}
dlognorm <- function(x, m, sd){
  return(-0.5*log(2*pi*sd^2)-(x-m)^2/(2*sd^2))
}

dloginvgamma <- function(x, a, b){
  return(a*log(b)-log(gamma(a))-(a+1)*log(x)-b/x)
}
```


```{r}
logf <- function(x, Y=Ydye, para=par){
  V <- x[1]; W <- x[2]; mu <- x[3]; theta <- x[4:length(x)]
  if  (V<=0 || W<=0){
    return(0)
  }
  a1 <- para[1]; b1 <- para[2]; a2 <- para[3]; b2 <- para[4]; a3 <- para[5]; b3 <- para[6];
  
  f_v <- dloginvgamma(V, a1, b1)
  f_w <- dloginvgamma(W, a2, b2)
  f_u <- dlognorm(mu, a3, sqrt(b3))
  
  f_theta <- 0
  for (i in 1:length(theta)){
    f_theta_i <- dlognorm(theta[i], mu, sqrt(V))
    f_theta <- f_theta + f_theta_i
  }
  
  f_y <- 0
  for(i in 1:length(theta)){
    for(j in 1:length(Ydye[i,])){
      f_y_i <- dlognorm(Ydye[i,j],theta[i],sqrt(W))
      f_y <- f_y + f_y_i
    }
  }
  
  logf <- f_v+f_w+f_u+f_theta+f_y
  if (logf == -Inf){
    return(0)
  }
  else{
    return(logf) 
  }
  
}

f <- function(x, Y=Ydye, para=par){
  logf_val <- logf(x, Y, para)
if (logf_val == 0){
    return(0)
  }
  else{
    return(exp(logf(x, Y, para)))
  }
}
```


```{r}
x <- c(1.1,3000,1520,1520,1520,1520,1520,1520,1520)

int1 <- adaptIntegrate(logf, lowerLimit = x-rep(0.5, length(x)), upperLimit = x-rep(0.0, length(x)))

int1_val <- int1$integral-int1$error

L=exp(int1_val)
L
```
According to equation 15, an upper bound on K is as follows,
```{r}
K <- log(sup_ratio)-int1_val
K <- exp(K)
K
```
```{r}
df_diff_all %>%
  mutate(diff=diff*K) %>% 
  group_by(iter) %>%
  summarise(mean_diff = mean(diff), min_diff =  min(diff), max_diff = max(diff),lq_diff =  quantile(diff, probs = c(0.25)), uq_diff = quantile(diff, probs = c(0.75))) %>% 
  filter(iter>2) %>%  
  ggplot(aes(x = iter)) +
  geom_ribbon(aes(ymin = min_diff, ymax = max_diff), fill = 'grey', alpha=0.5) +
  geom_ribbon(aes(ymin = lq_diff, ymax = uq_diff), fill = 'grey', alpha=0.75) +
  geom_line(aes(y = mean_diff), size=1) + scale_y_log10() +
  theme_bw() + geom_hline(yintercept=0.01) +
  #labs(title = TeX("Value of $||X_n-X'_n||_1$"), subtitle = "Using common random number technique") +
  xlab(TeX("n=iteration")) + ylab(TeX("Logscale of $K||X_n-X'_n||_1$"))
```
```{r}
first_hit_wass <-
  df_diff_all %>%
  mutate(diff=diff*K) %>% 
  group_by(iter) %>%
  summarise(mean_diff = mean(diff)) %>% 
  filter(mean_diff<=0.01) %>% 
  summarise(min(iter))

first_hit_wass <- first_hit_wass$`min(iter)`

diff9900 <- df_diff_all %>%
  mutate(diff=diff*K) %>% 
  group_by(iter) %>%
  summarise(mean_diff = mean(diff)) %>% 
  filter(iter == first_hit_wass)

diff9900
  
```

## Comparing this bound to Cowles and Rosenthal's

Generate the initial value of $Y_0\sim \nu$
```{r}
par <- c(0.5,1.00001,0.00001,1.00001, 0, 10^(12))   # initial values from Cowles and Rosenthal. Note that b1 is not 1, but 1.0001. This is because our method requires b1>1.
a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
```

```{r}
# Generate initial values that are aligned with Cowles and Rosenthal
batch_m <- apply(Ydye,1,mean)
bar_y <- mean(Ydye)
v1 <- sum((Ydye-batch_m)^2)/(I*J)
v2 <- sum((batch_m-bar_y)^2)/I

theta <- (J*v1*batch_m +v2*bar_y)/(J*v1+v2)
u <- bar_y
```


```{r}
simVCM <- function(){ #same as previous simVCM function except that X_init is different and W is assigned 0 (since choice of priors would result in Inf)
  M <- 700
  a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
  
  #initial value of mu and theta in Y coincides with V(X_0)=0 (eqn 9 from Cowles and Rosenthal paper). initial values of V and W are taken as conditional distributions given mu and theta.
  V <- rinvgamma(1, a1 + I/2, b1+sum((theta-u)^2))
  W <- rinvgamma(1, a2+I*J/2, b2 + sum((Ydye-theta)^2))
  Y <- c(V[1], W[1], u, theta)
  Y_init <- Y
  
  # initial value of X coincides with eqn 6 from paper
  V <- rinvgamma(1, a1, b1-1)
  W <- rinvgamma(1, a2, 0)
  u <- rnorm(1, a3, sqrt(b3))
  theta <- rnorm(I, apply(Ydye,2,mean), W/J)
  X <- c(V[1], W[1], u[1], theta)
  X_init <- X

  df_X <- data.frame(t(c(X,0,0)))
  df_Y <- data.frame(t(c(Y,0,0)))
  colnames(df_X) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")
  colnames(df_Y) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")

 # a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];

  for (i in 1:M) {
      for (coord in 1:4){
        if (coord == 3) { # Modify coordinate u
          z = rnorm(1,0,1)
          X <- gibbs_update_u(X, z)
          Y <- gibbs_update_u(Y, z)
        }
        else if (coord == 4) { # Modify all I thetas
          z = rnorm(I,0,1)
          X <- gibbs_update_theta(X, z)
          Y <- gibbs_update_theta(Y, z)
        }
        else if (coord == 1) { # Modify coordinate V
          g = rgamma(1, shape = a1+I/2, rate = 1)
          X <- gibbs_update_V(X, g)
          Y <- gibbs_update_V(Y, g)
        }
        else if (coord == 2) { # Modify coordinate W
          g = rgamma(1, shape = a2+I*J/2, rate = 1)
          X <- gibbs_update_W(X,g)
          Y <- gibbs_update_W(Y,g)
        }
        df_X <- rbind(df_X,c(X, coord, i))
        df_Y <- rbind(df_Y,c(Y, coord, i))
      }
  }

  df_X1 <- df_X %>% pivot_longer(cols = V:theta6, names_to = "names", values_to = "X")
  df_Y1 <- df_Y %>% pivot_longer(cols = V:theta6, names_to = "names", values_to = "Y")

  df <- left_join(df_X1, df_Y1, by=c('coord','iter','names'))
  df <- df %>% mutate(diff = X-Y)

  df_diff <- df %>%
    filter(coord ==1) %>%
    group_by(iter) %>%
    summarise(diff = sum(abs(diff)))
  return(df_diff)
}
```

```{r}
# df_diff_all <- simVCM()
# df_diff_all <- df_diff_all %>% mutate(sim_no=1)
# for (i in 2:2000){
#   df_diff <- simVCM()
#   df_diff <- df_diff %>% mutate(sim_no=i)
#   df_diff_all <- rbind(df_diff_all,df_diff)
# }
# 
# save(df_diff_all, file = "df_diff_all_Cowles_VarComp.RData")
```

```{r}
load('df_diff_all_Cowles_VarComp.RData')
```



```{r}
df_diff_all %>%
  group_by(iter) %>%
  summarise(mean_diff = mean(diff), min_diff =  min(diff), max_diff = max(diff)) %>% 
  filter(iter==471)
```


## Find the constant $K$ from theorem 4.4 with priors specified by Cowles
Generating bound between |X_n-Y_n| and |X_n-X_infty|

```{r}
V_star <- 2/I
W_star <- 2/(J*I-I)

C <- (b1/(b1-1))^a1*(b2/(b2-1))^a2*1/((2*pi)^(I*J/2)*J^(1/2))

sup_ratio <- C*(exp(-1/V_star)/(V_star)^(I/2))*(exp(-1/W_star)/(W_star)^((J*I-I)/2))
sup_ratio
```

```{r}
x <- c(1000,3000,1520,1520,1520,1520,1520,1520,1520)

int1 <- adaptIntegrate(logf, lowerLimit = x-rep(0.5, length(x)), upperLimit = x+rep(0.10, length(x)))

int1_val <- int1$integral-int1$error

L=exp(int1_val)
L
```
According to equation 15, an upper bound on K is as follows,
```{r}
K <- log(sup_ratio)-int1_val
K <- exp(K)
K
```

```{r}
df_diff_all %>%
  mutate(diff=diff*K) %>% 
  group_by(iter) %>%
  summarise(mean_diff = mean(diff), min_diff =  min(diff), max_diff = max(diff),lq_diff =  quantile(diff, probs = c(0.25)), uq_diff = quantile(diff, probs = c(0.75))) %>% 
  filter(iter>2) %>%  
  ggplot(aes(x = iter)) +
  geom_ribbon(aes(ymin = min_diff, ymax = max_diff), fill = "grey70", alpha=0.50) +
  geom_ribbon(aes(ymin = lq_diff, ymax = uq_diff), fill = "grey70", alpha=0.750) +
  geom_line(aes(y = mean_diff),size=1) + scale_y_log10() + geom_hline(yintercept=0.01) +
  #labs(title = TeX("Value of $K||X_n-X'_n||_1$"), subtitle = "Using common random number technique") +
  theme_bw() +
  xlab(TeX("n=iteration")) + ylab(TeX("Logscale of $K||X_n-X'_n||_1$"))
```

## Generate bound in TV from Wass distance. 

```{r}
# I <- dim(Ydye)[2]
# J <- dim(Ydye)[1]

c1=(2/I)*(I/2+a1)*(1+sqrt(2/b1)*1/I+1/(2*b1*I^2))^(I/2+a1-1)*(sqrt(2/b1)+1/(b1*I))

c2=2/(I*J^(3/2))*((I*J)/2+a2)*(1+2/(sqrt(b2)*I*J)+1/(b2*I^2*J^2))^(I*J/2+a2-1)*(2*sqrt(J/b2)+2/(b2*sqrt(J)*I))

TV <- (c1+c2)*J^(1.5)*I
TV
K*TV
```

```{r}
diffTV <- df_diff_all %>%
  group_by(iter) %>%
  summarise(mean_diff = mean(diff)*K*TV, min_diff =  min(diff)*K*TV, max_diff = max(diff)*K*TV) 
diffTV %>% 
  filter(iter>2) %>%  
  ggplot(aes(x = iter)) +
  geom_ribbon(aes(ymin = min_diff, ymax = max_diff), fill = "grey70", alpha=0.75) +
  geom_line(aes(y = mean_diff)) + scale_y_log10() + geom_hline(yintercept=0.01) +
  labs(title = TeX("Upper bound on $||X_n-X_{\\infty}||_{TV}$"), subtitle = "Using common random number technique") +
  xlab(TeX("n=iteration")) + ylab(TeX("Log scale of $K*TV*||X_n-X_{\\infty}||_{TV}$"))
```

```{r}
first_hit_wass <- diffTV %>% 
  filter(mean_diff <= 0.01) %>% 
  summarise(first_hit_wass=min(iter))

first_hit_wass <- first_hit_wass$first_hit_wass

diffTV %>%
  filter(iter == first_hit_wass)

```




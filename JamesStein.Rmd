---
title: "JamesStein"
output: html_document
date: "2025-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(pscl)
library(tidyverse)
library(invgamma)
library(latex2exp)
library(cubature)
library(coda)
library(dplyr)
```

## James Stein Gibbs sampler

```{r}
data(EfronMorris)
```

## Including Plots

You can also embed plots, for example:

```{r}
Y <- EfronMorris$y
V <- var(Y)
V
# priors
a = 0.01
b <- 2

k <- length(Y)
```

```{r}
nextIt <- function(x, Z, Z_mu, G){
  # updating theta
  x[,thetanames] <- (Y*x$A+x$mu*V)/(x$A+V)+ sqrt((V*x$A)/(V+x$A))*Z
  # updating A
  x$A <- (sum((x[,thetanames]-x$mu)^2)/2+b)*G
  # updating mu
  x$mu <- sum(x[,thetanames])/k+sqrt(x$A/k)*Z_mu
  return(x)
}
```

```{r}
# I = 1000
# J = 20
# 
# diff <- matrix(0, I, J)
# it1 <- data.frame(cbind(sort(rep(1:I,J)), rep(1:J,I), matrix(0, I*J, k+2)))
# it2 <- data.frame(cbind(sort(rep(1:I,J)), rep(1:J,I), matrix(0, I*J, k+2)))
# thetanames <- c(paste("theta", 1:k, sep = ""))
# vnames <- c("A","mu",thetanames)
# cnames <- c("sim_no","it", vnames)
# colnames(it1) <- cnames
# colnames(it2) <- cnames
# 
# for(i in 1:I){
# 
# #initializing the chains. it1~nu and it2
#   it1[it1$it==1 & it1$sim_no==i,paste("theta", 1:k, sep = "")] <- rnorm(k,Y,sqrt(V))
#   it1[it1$it==1 & it1$sim_no==i,"A"] <- rinvgamma(1,a+(k-1)/2,b)
#   it1[it1$it==1 & it1$sim_no==i,"mu"] <- rnorm(1,mean(as.numeric(it1[it1$it==1 & it1$sim_no==i,paste("theta", 1:k, sep = "")])),sqrt(it1[it1$it==1 & it1$sim_no==i,"A"]))
# 
#   #it2[it1$it==1 & it1$sim_no==i, c("A","mu",paste("theta", 1:k, sep = ""))] <- rep(mean(Y),k+2)
#   it2[it1$it==1 & it1$sim_no==i, c("A","mu",paste("theta", 1:k, sep = ""))] <- rep(100,k+2)
# 
#   for(j in 2:J){
#     Z <- rnorm(k, 0, 1)
#     Z_mu <- rnorm(1,0,1)
#     G <- rinvgamma(1, shape = a+(k-1)/2, 1)
#     it1[it1$it==j & it1$sim_no==i,vnames] <-
#       nextIt(it1[it1$it==(j-1) & it1$sim_no==i,vnames], Z, Z_mu, G)
#     it2[it1$it==j & it1$sim_no==i,vnames] <-
#       nextIt(it2[it1$it==(j-1) & it1$sim_no==i,vnames], Z, Z_mu, G)
#   }
# }
```

```{r}
# it1_long <- it1 %>%
#   pivot_longer("A":"theta18",names_to="par", values_to="val")
# it2_long <- it2 %>%
#   pivot_longer("A":"theta18",names_to="par", values_to="val")
# diff <- merge(it1_long, it2_long, by=c("it","sim_no","par")) %>%
#   mutate(diff = val.x-val.y)
# 
# save(diff, file = "diff_JamesStein.RData")
```

```{r}
load('diff_JamesStein.RData')
```

```{r}
diff_sum <- diff %>%
  group_by(it, sim_no) %>% 
  summarise(diff=sum(abs(diff)))
```

```{r}
diff_sum %>%
  group_by(it) %>% 
  summarize(mean_val = mean(abs(diff)), max_val = max(abs(diff)), min_val = min(abs(diff)),lq_val =  quantile(diff, probs = c(0.25)), uq_val = quantile(diff, probs = c(0.75))) %>% 
  ggplot(aes(x = it), ylim=c(0,10^6)) + 
  geom_ribbon(aes(ymin = min_val, ymax = max_val), fill = "grey70", alpha=0.5) + 
  geom_ribbon(aes(ymin = lq_val, ymax = uq_val), fill = "grey70", alpha=0.75) + 
  scale_y_log10() +
  geom_line(aes(y = mean_val)) + geom_hline(yintercept=0.01) +
  theme(legend.position = "none") +
  #labs(title = TeX("Value of $||(\\theta_n,\\mu_n,A_n)-(\\theta'_n,\\mu'_n,A'_n)||_1$"), subtitle = "Based on 1000 simulations") +
  xlab("n=iteration") + ylab(TeX("Logscale of $||(\\theta_n,\\mu_n,A_n)-(\\theta'_n,\\mu'_n,A'_n)||_1$"))
```

## Find the constant $K$ from theorem 4.4

```{r}
dlognorm <- function(x, m, sd){
  return(-0.5*log(2*pi*sd^2)-(x-m)^2/(2*sd^2))
}

dloginvgamma <- function(x, a, b){
  return(a*log(b)-log(gamma(a))-(a+1)*log(x)-b/x)
}
```

```{r}
f <- function(x, Y_val=Y, para=par){
  A <- x[1]; mu <- x[2]; theta <- x[3:length(x)]
  if  (A<=0 ){
    return(0)
  }
  a <- para[1]; b <- para[2];
  
  f_A <- dinvgamma(A, a, b)
  
  f_u <- 1;
  for(i in 1:length(theta)){
    f_u <- f_u*dnorm(mu, theta[i], sqrt(A))
  }
  
  f_theta <- 1;
  for(i in 1:length(theta)){
    #f_theta <- f_theta + dlognorm(Y[i], theta[i], sqrt(V))
    f_theta <- f_theta*dnorm(Y_val[i], theta[i], sqrt(V))
  }
  
  f <- f_A*f_u*f_theta
  
  return(f)
}
```


According to equation 15, an upper bound on K is as follows,
```{r}
L_int <- function(x, Y_val=Y, para=par){
  A <- x[1]; mu <- x[2]#; theta <- x[3:length(x)]
  if  (A<=0 ){
    return(0)
  }
  a <- para[1]; b <- para[2];
  
  sumY <- sum((Y_val/V+mu/A)^2/(1/A+1/V)-Y_val^2/V-mu^2/A)
  
  g <- A^(-a-1)*exp(-b/A)*(A+V)^(-k/2)*exp(sumY/2)
  
  return(g)
}
```

```{r}
# par <- c(a,b)
# x <- c(b/(a+1), mean(Y))
# xl_interval <- c(2,0.5)
# xu_interval <- c(1.5,1)
# xl <- x-xl_interval
# xu <- x+xu_interval
# int_f <- adaptIntegrate(L_int, lowerLimit = xl, upperLimit = xu)
# L <- int_f$integral
# L
# 
# C <- gamma(a+(k-1)/2)*(2*pi)^(1/2)/(b)^(a+(k-1)/2)
# C
# K <- C/L
# K
# save(K, file = "K_JamesStein.RData")
```
```{r}
load('K_JamesStein.RData')
```

```{r}
K
```
```{r}
p <- 1
diff_sum %>%
  group_by(it) %>% 
  summarize(mean_val = mean(abs(diff)^p), var_val = var(abs(diff)^p)) %>% 
  mutate(lci = K^(1/p)*(mean_val-qnorm(0.975)*sqrt(var_val/1000))^(1/p), 
         uci = K^(1/p)*(mean_val+qnorm(0.975)*sqrt(var_val/1000)^(1/p)))
```

```{r}
p <- 1
diff_sum_table <- diff_sum %>%
  group_by(it) %>% 
  summarize(mean_val = mean(abs(diff)^p), var_val = var(abs(diff)^p)) %>% 
  mutate(lci = K^(1/p)*(mean_val-qnorm(0.975)*sqrt(var_val/1000))^(1/p), 
         uci = K^(1/p)*(mean_val+qnorm(0.975)*sqrt(var_val/1000)^(1/p)))

diff_sum_table[is.na(diff_sum_table)] <- 0
diff_sum_table[diff_sum_table<0] <- 0

diff_sum_table %>% 
  filter(it>2) %>% 
  ggplot(aes(x = it), ylim=c(0,10^6)) + 
  geom_ribbon(aes(ymin = lci, ymax = uci), fill = 'grey', alpha=0.5) + 
  scale_y_log10() +
  geom_line(aes(y = (K*mean_val)^(1/p))) + geom_hline(yintercept=0.01, linetype=2) +
  theme_bw(base_size = 13) +
  #labs(title = TeX("Value of $||(\\theta_n,\\mu_n,A_n)-(\\theta_{\\infty},\\mu_{\\infty},A_{\\infty})||_1$"), subtitle = "Based on 1000 simulations") +
  xlab("n=iteration") + ylab(TeX("Logscale of $W(L(\\theta_n,\\mu_n,A_n),\\pi)$")) +
  geom_text(aes(19,0.0001,label = 'y=0.01', vjust = -1)) 
```
```{r}
p <- 1
diff_sum_table <- diff_sum %>%
  group_by(it) %>% 
  summarize(mean_val = mean(abs(diff)^p), var_val = var(abs(diff)^p)) %>% 
  mutate(lci = K^(1/p)*(mean_val-qnorm(0.975)*sqrt(var_val/1000))^(1/p), 
         uci = K^(1/p)*(mean_val+qnorm(0.975)*sqrt(var_val/1000))^(1/p))

diff_sum_table[is.na(diff_sum_table)] <- 0
diff_sum_table[diff_sum_table<0] <- 0

diff_sum_table %>% 
  filter(it>2) %>% 
  ggplot(aes(x = it), ylim=c(0,10^6)) + 
  geom_line(aes(y = uci), col='red') + 
  scale_y_log10() +
  geom_line(aes(y = (K*mean_val)^(1/p))) + geom_hline(yintercept=0.01, linetype=2) +
  theme_bw(base_size = 13) +
  xlab("n=iteration") + ylab(TeX("Logscale of $W(L(\\theta_n,\\mu_n,A_n),\\pi)$")) +
  geom_text(aes(19,0.0001,label = 'y=0.01', vjust = -1)) 
```


```{r}
diff_sum_table %>% 
  mutate(bnd_est = (K*mean_val)^(1/p)) %>% 
  dplyr::select(it, bnd_est, uci) %>% 
  pivot_longer(cols = bnd_est:uci, names_to = "Bound", values_to = "value") %>% 
  filter(it>2) %>% 
  ggplot(aes(x = it, y = value, color = Bound), ylim=c(0,10^6)) + 
  scale_color_manual(labels = c("Estimate", "97.5% upper C.I."), values = c("bnd_est" = "black", "uci" = "red")) +
  geom_line() + 
  scale_y_log10() +
  theme_bw(base_size=13) + theme(legend.position= 'bottom') +
  geom_hline(yintercept=0.01, linetype=2) +
  xlab("n=iteration") + ylab(TeX("Logscale of $W(L(\\theta_n,\\mu_n,A_n),\\pi)$")) +
  geom_text(aes(19,0.0001,label = 'y=0.01', vjust = -1, colour = 'black')) 
```


```{r}
first_hit <- diff_sum %>%
  mutate(diff =diff*K) %>% 
  group_by(it) %>% 
  summarize(mean_val = mean(diff)) %>% 
  filter(mean_val<=0.01) %>% 
  summarise(first_hit=min(it))

first_hit <- first_hit$first_hit
```
```{r}
diff_sum %>%
  group_by(it) %>% 
  summarize(mean_val = mean(abs(diff)*K), max_val = max(abs(diff)*K), min_val = min(abs(diff)*K)) %>% 
  filter(it==first_hit)
```

Calculate bound on total variation
```{r}
S <- sum((Y-mean(Y))^2)

TV <- (S/2)^((k-1)/2)/gamma((k-1)/2)*(S/(k+1))^(-(k-3)/2)*exp(-(k+1)/2)
TV
TV*K
```

Comparing our bound to the other bounds outlined in table 1.

```{r}
# I <- 10000
# 
# it1 <- data.frame(cbind(1:I, matrix(100, I, k+2)))
# thetanames <- c(paste("theta", 1:k, sep = ""))
# vnames <- c("A","mu",thetanames)
# cnames <- c("sim_no", vnames)
# colnames(it1) <- cnames
# 
# it2 <- it1
# for (i in 1:I){
#   Z <- rnorm(k, 0, 1)
#   Z_mu <- rnorm(1,0,1)
#   G <- rinvgamma(1, shape = a+(k-1)/2, 1)
#   it2[it2$sim_no==i,vnames] <- nextIt(it1[it1$sim_no==i,vnames], Z, Z_mu, G)
# }
# 
# meandiff1 <- mean(abs(it1$A-it2$A))
# save(meandiff1, file = "meandiff1_JamesStein.RData")
```

```{r}
load('meandiff1_JamesStein.RData')
```

```{r}
crn_val <- diff_sum %>%
  group_by(it) %>% 
  summarize(crn_val = mean(diff*K*TV))

#initializing the chains. it1~nu and it2
#meandiff1 <- mean(abs((rinvgamma(1000,a+(k-1)/2,b)-rep(mean(Y),1000))))
#meandiff1 <- mean(abs((rinvgamma(1000,a+(k-1)/2,b)-rep(100,1000))))

it <- 1:138
dnm_val <- 0.967^(it)+(1.17+k*(mean(Y)-100)^2)*0.935^(it)
oneshot_val <- TV*meandiff1/(1-1/18)*(1/18)^(it-1)

#head(data.frame(dnm_val,oneshot_val),n=10)

dfTV_all <- data.frame(it=1:138, DnM = dnm_val,oneshot_val) %>% 
  left_join(crn_val, by='it')

colnames(dfTV_all) <- c('it','DnM','One Shot', 'CRN')
head(dfTV_all, n=20)
```

```{r}
dfTV_all %>%
  pivot_longer(cols=c('DnM','One Shot', 'CRN'), names_to = 'bound', values_to = 'val') %>% 
  filter(it<21) %>% 
  ggplot(aes(x = it, y = val, colour=bound)) +
  geom_line(aes(lty=bound), size=1) +
  xlab(TeX("n=iteration")) + ylab(TeX("Logscale of $||L(\\theta_n,\\mu_n, A_n)-\\pi||_{TV}$")) +
  theme_bw(base_size=13) + theme(legend.position= 'bottom') + scale_y_log10() +
  scale_color_manual(values = c('black','skyblue','plum3')) + geom_hline(yintercept=0.01, linetype=2) + geom_text(aes(19,0.0001,label = 'y=0.01', vjust = -0.5)) 
```


```{r}
# diff_sum %>%
#   group_by(it) %>% 
#   summarize(crn_val = mean(abs(diff))) %>% 
#   filter(it<11)
```
```{r}
it <- 249
0.967^(it)+(1.17+k*(mean(Y)-100)^2)*0.935^(it)

#one shot val at it 249
TV*meandiff1*(1/18)^(it-1)
```

# Produce traceplots

```{r}
diff %>% 
  mutate(sim_no = as.character(sim_no)) %>% 
  filter(sim_no<20, par =='A' | par == 'mu' | par == 'theta1', it <11) %>% 
  ggplot(aes(x = it, y = val.y)) + facet_wrap(vars(par), scales = "free", labeller = labeller(par =
    c("A" = "A",
      "mu" = "mu",
      "theta1" = "theta 1"))) +
  geom_line(aes(col=sim_no)) + labs(y="Value", x="Iteration") +
  theme_bw() + theme(legend.position="none")
```

```{r}
diff %>% 
  mutate(sim_no = as.character(sim_no)) %>% 
  filter(sim_no<20, par =='A' | par == 'mu' | par == 'theta1', it>10) %>% 
  ggplot(aes(x = it, y = val.y)) + facet_wrap(vars(par), scales = "free", labeller = labeller(par =
    c("A" = "A",
      "mu" = "mu",
      "theta1" = "theta 1"))) +
  geom_line(aes(col=sim_no)) + labs(y="Value", x="Iteration") +
  theme_bw() + theme(legend.position="none") 
```
# Calculating Gelman Rubin diagnostic

```{r}
# # generate overdispersed simulations
# 
# init_val <- expand.grid(seq(0,150,25), seq(-100,100,50), seq(-100,100,50))
# init_val <- cbind(init_val, matrix(rep(init_val[,3],k-1), ncol=k-1))
# 
# I = dim(init_val)[1]
# J = 40
# 
# it <- data.frame(cbind(sort(rep(1:I,J)), rep(1:J,I), matrix(0, I*J, k+2)))
# thetanames <- c(paste("theta", 1:k, sep = ""))
# vnames <- c("A","mu", thetanames)
# cnames <- c("sim_no","it", vnames)
# colnames(it) <- cnames
# 
# for(i in 1:I){
# 
#   it[it$it==1 & it$sim_no==i, c("A","mu",paste("theta", 1:k, sep = ""))] <- init_val[i,]
# 
#   for(j in 2:J){
#     Z <- rnorm(k, 0, 1)
#     Z_mu <- rnorm(1,0,1)
#     G <- rinvgamma(1, shape = a+(k-1)/2, 1)
#     it[it$it==j & it$sim_no==i,vnames] <-
#       nextIt(it[it$it==(j-1) & it$sim_no==i,vnames], Z, Z_mu, G)
#   }
# }
# 
# save(it, file = "it_JamesStein.RData")
```

```{r}
# load('it_JamesStein.RData')
```

```{r}
# # Calculation of the Gelman Rubin diagnostic.
# # Gelman Rubin diagnostic for A
# gr_diagA <- seq(4,J,2) # values must be less than M+1
# for(j in 1:length(gr_diagA)){
#   it_J <- it %>%
#     filter(it <= gr_diagA[j])
# 
#   it_J_i <- it_J %>% filter(sim_no == 1) %>%
#     dplyr::select(A)
#   it_list <- list(mcmc(it_J_i))
#   for(i in 2:I){
#     it_J_i <- it_J %>% filter(sim_no == i) %>% dplyr::select(A)
#     it_list <- append(it_list, list(mcmc(it_J_i)))
#   }
#   gr <- gelman.diag(it_list)
#   gr_diagA[j] <- gelman.diag(it_list)$psrf[1,1]
# }
# gr_diagA
```
```{r}
# # Calculation of the Gelman Rubin diagnostic.
# # Gelman Rubin diagnostic for mu
# gr_diagMU <- seq(4,J,2) # values must be less than M+1
# for(j in 1:length(gr_diagMU)){
#   it_J <- it %>%
#     filter(it <= gr_diagMU[j])
# 
#   it_J_i <- it_J %>% filter(sim_no == 1) %>%
#     dplyr::select(mu)
#   it_list <- list(mcmc(it_J_i))
#   for(i in 2:I){
#     it_J_i <- it_J %>% filter(sim_no == i) %>% dplyr::select(mu)
#     it_list <- append(it_list, list(mcmc(it_J_i)))
#   }
#   gr <- gelman.diag(it_list)
#   gr_diagMU[j] <- gelman.diag(it_list)$psrf[1,1]
# }
# gr_diagMU
```
```{r}
# # Calculation of the Gelman Rubin diagnostic.
# # Gelman Rubin diagnostic for mu
# gr_diagTHETA1 <- seq(4,J,2) # values must be less than M+1
# for(j in 1:length(gr_diagTHETA1)){
#   it_J <- it %>%
#     filter(it <= gr_diagTHETA1[j])
# 
#   it_J_i <- it_J %>% filter(sim_no == 1) %>%
#     dplyr::select(theta1)
#   it_list <- list(mcmc(it_J_i))
#   for(i in 2:I){
#     it_J_i <- it_J %>% filter(sim_no == i) %>% dplyr::select(theta1)
#     it_list <- append(it_list, list(mcmc(it_J_i)))
#   }
#   gr <- gelman.diag(it_list)
#   gr_diagTHETA1[j] <- gelman.diag(it_list)$psrf[1,1]
# }
# gr_diagTHETA1
```

```{r}
# gr_diag <- data.frame(it = seq(4,J,2)/2, A = gr_diagA, mu = gr_diagMU, theta1 = gr_diagTHETA1)
# save(gr_diag, file = "gr_diag_JamesStein.RData")
```

```{r}
load('gr_diag_JamesStein.RData')
```

```{r}
gr_diag %>% 
  pivot_longer(cols = c('A','mu','theta1'), names_to = 'par', values_to = 'val') %>% 
  ggplot(aes(x = it, y = val)) + facet_wrap(vars(par), scales = "free", labeller = labeller(par =
    c("A" = "A",
      "mu" = "mu",
      "theta1" = "theta 1"))) +
  geom_line(aes()) + labs(y="Shrink factor", x="Iteration") +
  theme_bw() + theme(legend.position="none")
```
```{r}
gr_diag
```
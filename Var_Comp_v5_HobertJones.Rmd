---
title: "VarComp_v5"
output: html_document
date: "2025-08-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(matlib)
library(cubature)
library(latex2exp)
library(ggplot2)
library(MCMCpack)
library(coda)
library(Rmpfr)
library(dplyr)
```

#Variance Component Model Gibbs Sampler

The following is the data of interest. The rows represent the batches of which there are 6 in total. Each batch contains 5 elements.
```{r}
#Data comes from Table 1 of https://projecteuclid.org/journals/annals-of-statistics/volume-32/issue-2/Sufficient-burn-in-for-Gibbs-samplers-for-a-hierarchical-random/10.1214/009053604000000184.full
J <- 10 # number of Ys in each theta
I <- 5 # number of thetas

meanY <- c(-0.80247,-1.0014, -0.69090, -1.1413, -1.0125)
#s2 <- c(8.8650, 25.4900, 25.6359, 7.0935, 14.3590, 8.2691)
sse <- 32.990
sumY2 <- sse+J*sum(meanY^2)
```

The following code runs a Gibbs sampler for the model.

```{r}
gibbs_update_u <- function(x, z = rnorm(1,0,1)){
  a <- (a3*x[1]+b3*sum(x[4:(3+I)]))/(x[1]+I*b3)
  b <- sqrt(b3*x[1]/(x[1] + I*b3))
  x[3] <- a + b*z
  return(x)
}

gibbs_update_theta <- function(x, z = rnorm(I,0,1)){
  a <- (x[3]/x[1]+meanY*J/x[2])/(1/x[1]+J/x[2])
  b <- sqrt(1/(1/x[1] + J/x[2]))
  b <- sqrt(x[1]*x[2]/(x[2] + J*x[1]))
  x[4:(3+I)]  <- a + b * z
  return(x)
}

gibbs_update_V <- function(x, g = rgamma(1, shape = a1+I/2, rate = 1)){
  b <- b1 +sum((x[4:(3+I)]-x[3])^2)/2
  x[1]  <- b/g
  return(x)
}

gibbs_update_W <- function(x, g = rgamma(1, shape = a2+I*J/2, rate = 1)){
  b <- b2 + (sumY2-2*J*sum(x[4:(3+I)]*meanY)+J*sum(x[4:(3+I)]^2))/2
  x[2]  <- b/g
  return(x)
}
```

Generate the initial value of $Y_0\sim \nu$
```{r}
par <- c(2.5,1,1,1, mean(meanY), 1)# hyperparameters from Jones and Hobert are (2.5,1,1,1,mean(Y), 1). Difference are because limitations on Lemma 4.1.
#par <- c(6,6,1,6000, 1500, 500)
# par <- c(6, 6, 6, 6000, 1500, 500)
a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
```


```{r}
simVCM <- function(sim_no){
  a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];
  
  M <- 25
  
  V <- rinvgamma(1, 2*a1+1, 2*b1-1)
  W <- rinvgamma(1, 2*a2+1, 2*b2)
  u <- rnorm(1, a3, sqrt(b3))
  theta <- rnorm(I, meanY, sqrt(W/(2*J)))
  Y <- c(V[1], W[1], u[1], theta)
  Y_init <- Y

  # initial value of X based on Remark 4.1 of Hobert and Jones paper
  V <- rinvgamma(1, a1, b1)
  W <- rinvgamma(1, a2, b2)
  v1 <- sumY2/I; v2 <- mean((meanY-mean(meanY))^2);
  theta <- rnorm(I, (J*v1*meanY+v2*mean(meanY))/(J*v1+v2),1)
  u <- mean(theta)
  X <- c(V[1], W[1], u, theta)
  X_init <- X
  
  df_X <- data.frame(t(c(X,0,0)))
  df_Y <- data.frame(t(c(Y,0,0)))
  colnames(df_X) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")
  colnames(df_Y) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")
    
  for (i in 1:M) {
      for (coord in 1:4){
        if (coord == 3) { # Modify coordinate u
          z = rnorm(1,0,1)
          X <- gibbs_update_u(X, z)
          Y <- gibbs_update_u(Y, z)
        }
        else if (coord == 4) { # Modify all I thetas
          z = rnorm(I,0,1)
          X <- gibbs_update_theta(X, z)
          Y <- gibbs_update_theta(Y, z)
        }
        else if (coord == 1) { # Modify coordinate V
          g = rgamma(1, shape = a1+I/2, rate = 1)
          X <- gibbs_update_V(X, g)
          Y <- gibbs_update_V(Y, g)
        }
        else if (coord == 2) { # Modify coordinate W
          g = rgamma(1, shape = a2+I*J/2, rate = 1)
          X <- gibbs_update_W(X,g)
          Y <- gibbs_update_W(Y,g)
        }
        df_X <- rbind(df_X,c(X, coord, i))
        df_Y <- rbind(df_Y,c(Y, coord, i))
      }
  }

  df_X1 <- df_X %>% pivot_longer(cols = V:theta5, names_to = "names", values_to = "X")
  df_Y1 <- df_Y %>% pivot_longer(cols = V:theta5, names_to = "names", values_to = "Y")
  
  df <- left_join(df_X1, df_Y1, by=c('coord','iter','names'))
  df <- df %>% mutate(diff = X-Y)
  
  df_diff <- df %>%
    filter(coord ==1 | coord == 0) %>%
    mutate(sim_no=as.character(sim_no))
  return(df_diff)
}
```


```{r}
# df_diff_all <- simVCM(1)
# for(i in 2:1000){
#   df <- simVCM(i)
#   df_diff_all <- rbind(df_diff_all, df)
#   #print(i)
# }
# 
# save(df_diff_all, file = "df_diff_all_HobertJones_VarComp.RData")
```

```{r}
load('df_diff_all_HobertJones_VarComp.RData')
```


Calculate $K$ for the variance component model.

```{r}
g <- function(x, para=par){
  mu <- x[1]; theta <- x[2:length(x)]
  a1 <- para[1]; b1 <- para[2]; a2 <- para[3]; b2 <- para[4]; a3 <- para[5]; b3 <- para[6];
  
  a1_new <- a1+I/2
  a2_new <- a2+J*I/2
  b1_new <- b1+sum((theta-mu)^2)/2
  b2_new <- b2+(sumY2-2*J*sum(theta*meanY)+J*sum(theta^2))/2

  g <- b1_new^(-a1_new)*exp(-(mu-a3)^2/(2*b3))*b2_new^(-a2_new)
  if(g<0){
    g <- 0
  }
  return(g*10^35) 
}
```

```{r}
# S <- sse
# R <- I*J-I/2
# 
# a1_new <- a1+I/2
# a2_new <- a2+J*I/2
# 
# C1 <- gamma(a1)*gamma(a2)*(2*pi)^(I*J/2+(I+1)/2)*sqrt(b3)/
#   (gamma(a1_new)*b1^a1*gamma(a2_new)*b2^a2)
# C2 <- (b2/(b2-1))^(2*a2)/(J^I)*gamma(R-1)/(2-S)^(R-1)*(gamma(a1-2)*b1^a1/(gamma(a1)*(b1-1)^(a1-2)))^2*sqrt(b3)*gamma(I/2+3)/(2^(1.5*(I+1)+R)*pi^((I-1)/2+R))
# C2 <- b1^(2*a1)*gamma(2*a1+1)*b2^(2*a2)*gamma(2*a2+1)*gamma(I/2-1)*gamma(R-1)/
#  (gamma(a1)^2*(2*b1-1)^(2*a1+1)*gamma(a2)^2*(2*b2)^(2*a2+1)*J^(I/2)*2^(I+J*I)*pi^(R+I/2)*S^(R-1))
# 
# x <- c(mean(meanY), meanY)
# l <- rep(1,I+1)
# 
# int1 <- adaptIntegrate(g, lowerLimit = x-l, upperLimit = x+l)
# L <- int1$integral/10^35
# K <- C1*sqrt(C2)/L
# K
# 
# save(L, file = "L_HobertJones_VarComp.RData")
# save(K, file = "K_HobertJones_VarComp.RData")
```

```{r}
load('L_HobertJones_VarComp.RData')
```

```{r}
load('K_HobertJones_VarComp.RData')
K
```
```{r}
r <- 1
df_diff_K <- df_diff_all %>% 
  group_by(sim_no, iter) %>% 
  summarise(diff=sum(abs(diff))) %>% 
  mutate(diff = diff^(2*r))
```
```{r}
df_diff_K %>% 
  group_by(iter) %>%
  summarise(mean_diff = mean(diff), var_diff = var(diff)) %>% 
  mutate(uci = K^(1/r)*(mean_diff+qnorm(0.99)*sqrt(var_diff/1000))^(1/(2*r)),
         lci = K^(1/r)*(mean_diff-qnorm(0.99)*sqrt(var_diff/1000))^(1/(2*r)),
         estimate = K^(1/r)*mean_diff^(1/(2*r))) %>% 
  dplyr::select(iter, estimate, uci) %>% 
  pivot_longer(cols = estimate:uci, names_to = "Bound", values_to = "value")  %>% 
  ggplot(aes(x = iter, y = value, color = Bound), ylim=c(0,10^6)) + 
  scale_color_manual(labels = c("Estimate", "99% upper C.I."), values = c("estimate" = "black", "uci" = "red")) +
  geom_line() + 
  scale_y_log10() +
  theme_bw(base_size=13) + theme(legend.position= 'bottom') +
  geom_hline(yintercept=0.01, linetype=2) +
  xlab("n=iteration") + ylab(TeX("Logscale of $W(L(\\theta_n,\\mu_n,A_n),\\pi)$")) +
  geom_text(aes(24,0.0001,label = 'y=0.01', vjust = -1, colour = 'black')) 
```

```{r}
df_diff_K %>% 
  group_by(iter) %>%
  summarise(mean_diff = mean(diff), var_diff = var(diff)) %>% 
  mutate(uci = K^(1/r)*(mean_diff+qnorm(0.99)*sqrt(var_diff/1000))^(1/(2*r)),
         lci = K^(1/r)*(mean_diff-qnorm(0.99)*sqrt(var_diff/1000))^(1/(2*r)),
         estimate = K^(1/r)*mean_diff^(1/(2*r))) %>% 
  dplyr::select(iter, mean_diff, lci, estimate, uci) %>% 
  filter(iter<11)
```


# Generate traceplots

```{r}
simX <- function(sim_no){
  a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];

  M <- 60
  # initial value of X coincides with eqn 6 from paper ie. V(X)=0
  V <- rinvgamma(1, a1, b1)
  W <- rinvgamma(1, a2, b2)
  v1 <- sumY2/I; v2 <- mean((meanY-mean(meanY))^2);
  theta <- (J*v1*meanY+v2*mean(meanY))/(J*v1+v2)
  u <- mean(theta)
  X <- c(V[1], W[1], u, theta)
  X_init <- X

  df_X <- data.frame(t(c(X,0,0)))
  colnames(df_X) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")

  a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];

  for (i in 1:M) {
      for (coord in 1:4){
        if (coord == 3) { # Modify coordinate u
          z = rnorm(1,0,1)
          X <- gibbs_update_u(X, z)
        }
        else if (coord == 4) { # Modify all I thetas
          z = rnorm(I,0,1)
          X <- gibbs_update_theta(X, z)
        }
        else if (coord == 1) { # Modify coordinate V
          g = rgamma(1, shape = a1+I/2, rate = 1)
          X <- gibbs_update_V(X, g)
        }
        else if (coord == 2) { # Modify coordinate W
          g = rgamma(1, shape = a2+I*J/2, rate = 1)
          X <- gibbs_update_W(X,g)
        }
        df_X <- rbind(df_X,c(X, coord, i))
      }
  }
  df_X <- df_X %>%
    mutate(sim_no=as.character(sim_no))
  return(df_X)
}
```


```{r}
# df_X <- simX(1)
# for(i in 2:10){
#   df <- simX(i)
#   df_X <- rbind(df_X, df)
#   #print(i)
# }
# 
# save(df_X, file = "df_X_VarComp_HobertJones.RData")
```

```{r}
load('df_X_VarComp_HobertJones.RData')
```

```{r}
df_X %>% 
  filter(coord == 1, iter>5) %>% 
  dplyr::select(V,W,mu,iter,sim_no) %>% 
  pivot_longer(cols= V:mu, names_to = 'coord', values_to = 'val') %>% 
  ggplot(aes(x = iter, y = val)) + facet_wrap(vars(coord), scales = "free") +
  geom_line(aes(col=sim_no)) + theme_bw() + theme(legend.position="none")
```
# Calculate Gelman Rubin diagnostic

```{r}
simX_GR <- function(X, M, sim_no){
  a1 <- par[1]; b1 <- par[2]; a2 <- par[3]; b2 <- par[4]; a3 <- par[5]; b3 <- par[6];

  df_X <- data.frame(t(c(X,0,0)))
  colnames(df_X) <- c("V","W","mu",paste("theta",1:I, sep=""),"coord","iter")

  for (i in 1:M) {
      for (coord in 1:4){
        if (coord == 3) { # Modify coordinate u
          z = rnorm(1,0,1)
          X <- gibbs_update_u(X, z)
        }
        else if (coord == 4) { # Modify all I thetas
          z = rnorm(I,0,1)
          X <- gibbs_update_theta(X, z)
        }
        else if (coord == 1) { # Modify coordinate V
          g = rgamma(1, shape = a1+I/2, rate = 1)
          X <- gibbs_update_V(X, g)
        }
        else if (coord == 2) { # Modify coordinate W
          g = rgamma(1, shape = a2+I*J/2, rate = 1)
          X <- gibbs_update_W(X,g)
        }
        df_X <- rbind(df_X,c(X, coord, i))
      }
  }
  df_X <- df_X %>%
    mutate(sim_no=as.character(sim_no))
  return(df_X)
}
```



```{r}
V <- seq(0.01, 2.01, 0.5)
W <- seq(0.01, 2.01, 0.5)
u <- seq(-2,0,0.5)

X <- expand.grid(V,W,u)
X <- cbind(X,X[,3],X[,3],X[,3],X[,3],X[,3])

l <- nrow(X)

M <- 120
X_sim <- simX_GR(as.vector(X[1,], mode = "numeric"), M, 1)
for(i in 2:l){
  df <- simX_GR(as.vector(X[i,], mode = "numeric"), M, i)
  X_sim <- rbind(X_sim, df)
}
save(X_sim, file = "X_sim_VarComp_HobertJones.RData")
```
```{r}
# load("X_sim_VarComp_HobertJones.RData")
```

```{r}
# X_sim <- X_sim %>% 
#   filter(coord == 4 | coord == 0)
```

```{r}
# # Gelman Rubin diagnostic for V
# gr_diagV <- seq(20,120,20) # values must be less than M+1
# for(j in 1:length(gr_diagV)){
#   X_simJ <- X_sim %>%
#     filter(iter <= gr_diagV[j])
# 
#   X_simJ_i <- X_simJ %>% filter(sim_no == 1) %>%
#     dplyr::select(V)
#   it_list <- list(mcmc(X_simJ_i))
#   for(i in 2:l){
#     X_simJ_i <- X_simJ %>% filter(sim_no == i) %>% dplyr::select(V)
#     it_list <- append(it_list, list(mcmc(X_simJ_i)))
#   }
#   gr <- gelman.diag(it_list)
#   gr_diagV[j] <- gelman.diag(it_list)$psrf[1,1]
# }
# gr_diagV
```

```{r}
# # Gelman Rubin diagnostic for W
# gr_diagW <- seq(20,120,20) # values must be less than M+1
# for(j in 1:length(gr_diagW)){
#   X_simJ <- X_sim %>%
#     filter(iter <= gr_diagW[j])
# 
#   X_simJ_i <- X_simJ %>% filter(sim_no == 1) %>%
#     dplyr::select(W)
#   it_list <- list(mcmc(X_simJ_i))
#   for(i in 2:l){
#     X_simJ_i <- X_simJ %>% filter(sim_no == i) %>% dplyr::select(W)
#     it_list <- append(it_list, list(mcmc(X_simJ_i)))
#   }
#   gr <- gelman.diag(it_list)
#   gr_diagW[j] <- gelman.diag(it_list)$psrf[1,1]
# }
# gr_diagW
```
```{r}
# # Gelman Rubin diagnostic for mu
# gr_diagmu <- seq(20,120,20) # values must be less than M+1
# for(j in 1:length(gr_diagmu)){
#   X_simJ <- X_sim %>%
#     filter(iter <= gr_diagmu[j])
# 
#   X_simJ_i <- X_simJ %>% filter(sim_no == 1) %>%
#     dplyr::select(mu)
#   it_list <- list(mcmc(X_simJ_i))
#   for(i in 2:l){
#     X_simJ_i <- X_simJ %>% filter(sim_no == i) %>% dplyr::select(mu)
#     it_list <- append(it_list, list(mcmc(X_simJ_i)))
#   }
#   gr <- gelman.diag(it_list)
#   gr_diagmu[j] <- gelman.diag(it_list)$psrf[1,1]
# }
# gr_diagmu
```
```{r}
# gr_diag <- data.frame(it = seq(20,120,20)/2, V = gr_diagV, W = gr_diagW, mu = gr_diagmu)
# save(gr_diag, file = "gr_diag_VarComp_GelmanHobert.RData")
```

```{r}
load('gr_diag_VarComp_GelmanHobert.RData')
```

```{r}
gr_diag
```
